# Copyright (C) 2014. Ben Pruitt & Nick Conway
# See LICENSE for full GPLv2 license.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
"""
mascpcr.ioutil
~~~~~~~~~~~~~~

Methods related to output file generation. Includes functions to generate both
a comprehensive MASC PCR report and an IDT-style .xlsx order form.

"""

import itertools
import os

import openpyxl

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ CSV Report ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #
def getPrimerPairProductSize(pc1, pc2):
    """Calculate PCR product size (bp) generated by two PrimerCandidates

    Args:
        pc1 (``PrimerCandidate``)   : One primer in a pair
        pc2 (``PrimerCandidate``)   : The other primer in a pair

    Returns:
        Integer value representing the PCR product size in bp

    Raises:
        ``ValueError``

    """
    if pc1.strand == pc2.strand:
        raise ValueError('Both ``PrimerCandidate``s bind to the same strand')
    pc1_5p_idx = pc1.idx
    pc2_5p_idx = pc2.idx
    if pc1.strand == -1:
        pc1_5p_idx += pc1.length
    if pc2.strand == -1:
        pc2_5p_idx += pc2.length
    return abs(pc1.idx - pc2.idx)


def writePrimerRec(fd, pc, idx_lut, recoded_idx=True, gen_wt_idx=False):
    """ Write a single primer record to the provided open file descriptor

    A primer record consists of all of the relevant information contained 
    within a ``PrimerCandidate`` namedtuple in csv format:

        <strand, 1 or -1>,<recoded_idx, if relevant>,<wt_idx, if relevant>,
        <length in bp>,<sequence>,<number of mismatches>,<tm>,<hairpin tm>,
        <homodimer tm>

    Args:
        fd (file)                       : open file descriptor to which to 
                                          write the primer record
        pc (``PrimerCandidate``)        : PrimerCandidate namedtuple for which
                                          to write the record

        recoded_idx (bool, optional)    : (bool) whether or not the primer's 
                                          index is in the recoded genome idx 
                                          space or the wt genome idx space
        gen_wt_idx (bool, optional)     : if ``recoded_idx`` is ``True``, 
                                          specifies that the index on the wt 
                                          genome should be calculated (used for
                                          common primers)
    
    Returns:
        ``None``

    """
    if recoded_idx:
        if gen_wt_idx:
            pc_idx = '{},{}'.format(pc.idx, idx_lut[pc.idx])
        else:
            pc_idx = '{},N/A'.format(pc.idx, idx_lut[pc.idx])
    else:
        pc_idx = 'N/A,{}'.format(pc.idx)
    fd.write(','.join([str(x) for x in [
        pc.strand, pc_idx, pc.length, pc.seq, sum(pc.mismatch_idxs),
        max(0, pc.tm), max(0, pc.tm_hairpin), max(0, pc.tm_homo)]]) + '\n')


def writeCsvReport(idx_lut, set_of_primer_sets, combined_bins, params):
    """Write a pipeline output report in .csv format

    The report contains general information related to the number of 
    primer candidates found in each bin, the bin sizes, primer pair scores, 
    etc, as well as detailed information for each of the primers in the 
    final set of sets. Some information related to the output is garnered 
    from the ``params`` dictionary::

        The filepath is built using ``params['output_fp'] + 
        params['output_basename'] + '_masc_report.csv'``

        If params['dump_params'] is ``True``, the parameters dictionary will
        be dumped to the output file after the rest of the report is written.

    Args:
        idx_lut (``numpy.ndarray``) : numpy array of index mapping from recoded
                                      to wt genome
        set_of_primer_sets (list)   : list of length equal to the number of 
                                      bins specifying the primer set chosen 
                                      from each bin (see code in 
                                      :module:``mascpcr.pipeline``)
        combined_bins (list)        : list of length equal to the number of 
                                      bins containing sorted lists of primer 
                                      sets for each respective bin
        params (dict)               : parameters dictionary used throughout the 
                                      pipeline (see 
                                      :module:``mascpcr.pipeline``)

    Returns:
        ``None``

    """
    output_fp = os.path.join(params['output_fp'], params['output_basename'] + 
                             '_masc_report.csv')

    with open(output_fp, 'w') as fd_out:

        fd_out.write(','.join([
            'Bin number',
            'Potential pairs found',
            'Pair chosen',
            'Ideal PCR product size',
            'Actual PCR product size',
            'Pair score',
            'Included # of gen9 fragment junctions',
            'Discriminatory power (# mismatches)'
            ]) + '\n')

        for bin_idx, ps_idx in enumerate(set_of_primer_sets):
            primer_set = combined_bins[bin_idx][ps_idx]
            fp = primer_set.d_primer
            rp = primer_set.c_primer
            fd_out.write(','.join([str(x) for x in [
                bin_idx + 1,
                len(combined_bins[bin_idx]),
                ps_idx,
                params['product_sizes'][bin_idx],
                getPrimerPairProductSize(fp, rp),
                primer_set[0],
                int(primer_set[0])/50,
                sum(fp.mismatch_idxs)
                ]]) + '\n')

        fd_out.write('\n' + ','.join([
            'Bin number',
            'Primer type',
            'Strand',
            'Recoded Index',
            'Wildtype Index',
            'Length',
            'Sequence',
            'Number of mismatches',
            'Tm (C)',
            'Hairpin Tm (C)',
            'Homodimer Tm (C)'
            ]) + '\n')

        for bin_idx, ps_idx in enumerate(set_of_primer_sets):
            primer_set = combined_bins[bin_idx][ps_idx]
            d_primer = primer_set.d_primer
            w_primer = primer_set.w_primer
            c_primer = primer_set.c_primer
            fd_out.write('{},Discriminatory primer,'.format(bin_idx+1))
            writePrimerRec(fd_out, d_primer, idx_lut)
            fd_out.write(',Wildtype primer,')
            writePrimerRec(fd_out, w_primer, idx_lut, recoded_idx=False)
            fd_out.write(',Common primer,')
            writePrimerRec(fd_out, c_primer, idx_lut, gen_wt_idx=True)

        if params['dump_params']:
            fd_out.write('\nDESIGN PARAMETERS' + '\n' + '\n'.join(
                ['{},{}'.format(k, repr(v).replace(',', ';')) for k, v in
                 params.items()]))

    print('Wrote output report to %s' % output_fp)


# ~~~~~~~~~~~~~~~~~~~~~~~~~~ IDT-format .xslx file ~~~~~~~~~~~~~~~~~~~~~~~~~~ #
_IDT_HEADERS = ['WellPosition', 'Name', 'Sequence', 'Notes']
_IDT_HEADER_POSITIONS = ['A1', 'B1', 'C1', 'D1']

def wellGen():
    """Return well ID by row (A1, A2, ... A11, A12, B1, B2, ... B11, B12, etc)
    """
    for col, row in itertools.product('ABCDEFGH', range(1, 13)):
        yield col + ('%02d' % row)


def writeIdtXslxFile(idx_lut, set_of_primer_sets, combined_bins, params):
    """Write an IDT-style order file in .xlsx format

    The IDT order format is comprised of 3 columns: 'WellPosition', 'Name', and
    'Sequence'. This function populates the file in row order (A1->A12, 
    B1->B12) and generates the primer names using this convention::

        <``params['output_basename']``>.<bin number>.<primer type, 'w'/'d'/'c'>

    Here is an example header and first row from an output file::


        WellPosition    Name        Sequence
        A1              seg2.1.w    ATGACCAGGTTGACCAGTGGAGC

        In this case, ``params['output_basename'] is 'seg2'.

        The filepath is built using ``params['output_fp'] + 
        params['output_basename'] + '_masc_order.xslx'``


    Args:
        idx_lut (``numpy.ndarray``) : numpy array of index mapping from recoded 
                                      to wt genome
        set_of_primer_sets (list)   : list of length equal to the number of 
                                      bins specifying the primer set chosen 
                                      from each bin (see code in 
                                      :module:``mascpcr.pipeline``)
        combined_bins (list)        : list of length equal to the number of 
                                      bins containing sorted lists of primer 
                                      sets for each respective bin
        params (dict)               : parameters dictionary used throughout 
                                      the pipeline (see 
                                      :module:``mascpcr.pipeline``)

    Returns:
        ``None``

    """
    ob = params['output_basename']
    wb = openpyxl.Workbook()
    ws = wb.active
    for cell_id, header in zip(_IDT_HEADER_POSITIONS, _IDT_HEADERS):
        ws.cell(cell_id).value = header
    cur_row = 2
    wg = wellGen()
    for bin_idx, set_idx in enumerate(set_of_primer_sets):
        primer_set = combined_bins[bin_idx][set_idx]
        # Discriminatory primer
        ws.cell('A%d' % cur_row).value = wg.next()
        ws.cell('B%d' % cur_row).value = '%s.%d.d' % (ob, bin_idx + 1)
        ws.cell('C%d' % cur_row).value = primer_set.d_primer.seq
        cur_row += 1
        # Wildtype primer
        ws.cell('A%d' % cur_row).value = wg.next()
        ws.cell('B%d' % cur_row).value = '%s.%d.wt' % (ob, bin_idx + 1)
        ws.cell('C%d' % cur_row).value = primer_set.w_primer.seq
        cur_row += 1
        # Common primer
        ws.cell('A%d' % cur_row).value = wg.next()
        ws.cell('B%d' % cur_row).value = '%s.%d.c' % (ob, bin_idx + 1)
        ws.cell('C%d' % cur_row).value = primer_set.c_primer.seq
        cur_row += 1
    output_fp = os.path.join(params['output_fp'], params['output_basename'] + 
                          '_masc_order.xlsx')
    wb.save(output_fp)
    print('Wrote output .xlsx to %s' % output_fp)
